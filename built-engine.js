var pca = (function (exports) {
    'use strict';

    var parser = /*
     * Generated by PEG.js 0.10.0.
     *
     * http://pegjs.org/
     */
    (function() {

      function peg$subclass(child, parent) {
        function ctor() { this.constructor = child; }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
      }

      function peg$SyntaxError(message, expected, found, location) {
        this.message  = message;
        this.expected = expected;
        this.found    = found;
        this.location = location;
        this.name     = "SyntaxError";

        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, peg$SyntaxError);
        }
      }

      peg$subclass(peg$SyntaxError, Error);

      peg$SyntaxError.buildMessage = function(expected, found) {
        var DESCRIBE_EXPECTATION_FNS = {
              literal: function(expectation) {
                return "\"" + literalEscape(expectation.text) + "\"";
              },

              "class": function(expectation) {
                var escapedParts = "",
                    i;

                for (i = 0; i < expectation.parts.length; i++) {
                  escapedParts += expectation.parts[i] instanceof Array
                    ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
                    : classEscape(expectation.parts[i]);
                }

                return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
              },

              any: function(expectation) {
                return "any character";
              },

              end: function(expectation) {
                return "end of input";
              },

              other: function(expectation) {
                return expectation.description;
              }
            };

        function hex(ch) {
          return ch.charCodeAt(0).toString(16).toUpperCase();
        }

        function literalEscape(s) {
          return s
            .replace(/\\/g, '\\\\')
            .replace(/"/g,  '\\"')
            .replace(/\0/g, '\\0')
            .replace(/\t/g, '\\t')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
        }

        function classEscape(s) {
          return s
            .replace(/\\/g, '\\\\')
            .replace(/\]/g, '\\]')
            .replace(/\^/g, '\\^')
            .replace(/-/g,  '\\-')
            .replace(/\0/g, '\\0')
            .replace(/\t/g, '\\t')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
        }

        function describeExpectation(expectation) {
          return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }

        function describeExpected(expected) {
          var descriptions = new Array(expected.length),
              i, j;

          for (i = 0; i < expected.length; i++) {
            descriptions[i] = describeExpectation(expected[i]);
          }

          descriptions.sort();

          if (descriptions.length > 0) {
            for (i = 1, j = 1; i < descriptions.length; i++) {
              if (descriptions[i - 1] !== descriptions[i]) {
                descriptions[j] = descriptions[i];
                j++;
              }
            }
            descriptions.length = j;
          }

          switch (descriptions.length) {
            case 1:
              return descriptions[0];

            case 2:
              return descriptions[0] + " or " + descriptions[1];

            default:
              return descriptions.slice(0, -1).join(", ")
                + ", or "
                + descriptions[descriptions.length - 1];
          }
        }

        function describeFound(found) {
          return found ? "\"" + literalEscape(found) + "\"" : "end of input";
        }

        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
      };

      function peg$parse(input, options) {
        options = options !== void 0 ? options : {};

        var peg$FAILED = {},

            peg$startRuleIndices = { Start: 0 },
            peg$startRuleIndex   = 0,

            peg$consts = [
              function(scene, lines) { return { scene, lines } },
              function(head, tail) { return [head, ...tail] },
              function(head) { return [head] },
              function(entity) { return entity },
              peg$otherExpectation("comment"),
              "#",
              peg$literalExpectation("#", false),
              /^[^\n\r]/,
              peg$classExpectation(["\n", "\r"], true, false),
              function(content) { return { type: "comment", content: content.join("").trim() } },
              peg$otherExpectation("scene"),
              "Scene",
              peg$literalExpectation("Scene", false),
              "with",
              peg$literalExpectation("with", false),
              "background",
              peg$literalExpectation("background", false),
              "resolution",
              peg$literalExpectation("resolution", false),
              "x",
              peg$literalExpectation("x", false),
              function(id, background, w, h) { return { id, background, w, h } },
              peg$otherExpectation("placeholder"),
              "Placeholder",
              peg$literalExpectation("Placeholder", false),
              "=",
              peg$literalExpectation("=", false),
              function(name, value) { return indexPlaceholder(name, value) },
              peg$otherExpectation("entity (actor / object)"),
              function(base) { return { type: "entity", ...base } },
              peg$otherExpectation("entity type"),
              "Actor",
              peg$literalExpectation("Actor", false),
              "Object",
              peg$literalExpectation("Object", false),
              "sprite",
              peg$literalExpectation("sprite", false),
              "at",
              peg$literalExpectation("at", false),
              function(id, sprite, size, position) { return { id, sprite, size, position } },
              function(id, sprite, position) { return { id, sprite, size: spriteSize, position } },
              peg$otherExpectation("position"),
              "(",
              peg$literalExpectation("(", false),
              ",",
              peg$literalExpectation(",", false),
              ")",
              peg$literalExpectation(")", false),
              function(x, y) { return { x, y } },
              peg$otherExpectation("size"),
              "and",
              peg$literalExpectation("and", false),
              "size",
              peg$literalExpectation("size", false),
              function(size) { return relativeToAbsoluteSize(size) },
              peg$otherExpectation("interaction specification"),
              "Interaction",
              peg$literalExpectation("Interaction", false),
              "{",
              peg$literalExpectation("{", false),
              "}",
              peg$literalExpectation("}", false),
              function(entity, interactions) { return { type: "interaction", entity, interactions } },
              peg$otherExpectation("interactions"),
              peg$otherExpectation("interaction"),
              peg$otherExpectation("sequential interactions"),
              "->",
              peg$literalExpectation("->", false),
              function(current, next) {
                  	return { type: "seq_interaction", interaction: current, next }
                  },
              peg$otherExpectation("parallel interaction"),
              "&",
              peg$literalExpectation("&", false),
              function(head, tail) {
                  	return { type: "par_interaction", interactions: [head, tail] }
                  },
              peg$otherExpectation("conditional interaction"),
              function(ifBranch, elseIfBranches, elseBranch) { return { action: "conditional", ifBranch, elseIfBranches, elseBranch } },
              function(ifBranch, elseIfBranches) { return { action: "conditional", ifBranch, elseIfBranches } },
              function(ifBranch, elseBranch) { return { action: "conditional", ifBranch, elseBranch } },
              function(ifBranch) { return { action: "conditional", ifBranch } },
              peg$otherExpectation("if branch"),
              "if",
              peg$literalExpectation("if", false),
              function(conditions, interactions) { return { action: "conditional", conditions, interactions } },
              peg$otherExpectation("else-if branch"),
              "else",
              peg$literalExpectation("else", false),
              peg$otherExpectation("else-if branches"),
              peg$otherExpectation("else branch"),
              function(interactions) { return { action: "conditional", interactions } },
              peg$otherExpectation("conditions"),
              "not",
              peg$literalExpectation("not", false),
              function(not, head, tail) { head.negate=!!not; return [head, ...tail] },
              function(not, head) { head.negate=!!not; return [head] },
              peg$otherExpectation("condition"),
              "objective",
              peg$literalExpectation("objective", false),
              "started",
              peg$literalExpectation("started", false),
              function(objective) { return { type: "objective_started", objective } },
              "completed",
              peg$literalExpectation("completed", false),
              function(objective) { return { type: "objective_completed", objective } },
              "is",
              peg$literalExpectation("is", false),
              function(entity, status) { return { entity, type: "is", status } },
              "has",
              peg$literalExpectation("has", false),
              function(entity, item) { return { entity, type: "has", item } },
              "go",
              peg$literalExpectation("go", false),
              "to",
              peg$literalExpectation("to", false),
              "scene",
              peg$literalExpectation("scene", false),
              function(scene) { return { action: "goto_scene", scene } },
              "player",
              peg$literalExpectation("player", false),
              "completes",
              peg$literalExpectation("completes", false),
              function(objective) { return { action: "completed_objective",  objective } },
              "given",
              peg$literalExpectation("given", false),
              function(objective) { return { action: "new_objective",  objective } },
              "display",
              peg$literalExpectation("display", false),
              function(text) { return { action: "display", text } },
              "gets",
              peg$literalExpectation("gets", false),
              function(entity, status) { return { entity, action:"gets", status } },
              "says",
              peg$literalExpectation("says", false),
              function(entity, message) { return { entity, action:"says", message } },
              "gives",
              peg$literalExpectation("gives", false),
              function(entity, item, toEntity) { return { entity, action:"give", item, toEntity } },
              "receives",
              peg$literalExpectation("receives", false),
              function(entity, item) { return { entity, action:"receives", item } },
              "disappears",
              peg$literalExpectation("disappears", false),
              function(entity) { return { entity, action:"disappear" } },
              "moves",
              peg$literalExpectation("moves", false),
              "over",
              peg$literalExpectation("over", false),
              function(entity, position, time) { return { entity, action:"move_to", position, time } },
              function(entity, position) { return { entity, action:"move_to", position, time: 0 } },
              peg$otherExpectation("time"),
              function(amount, unit) { return resolveTime(amount, unit) },
              peg$otherExpectation("time unit"),
              "m",
              peg$literalExpectation("m", false),
              "s",
              peg$literalExpectation("s", false),
              "ms",
              peg$literalExpectation("ms", false),
              function(name) { return lookupPlaceholder(name, ["string"]) },
              peg$otherExpectation("placeholder name"),
              /^[^ \t\r\n]/,
              peg$classExpectation([" ", "\t", "\r", "\n"], true, false),
              function() { return text() },
              peg$otherExpectation("value"),
              function(value) { return { type:'string', value } },
              function(value) { return { type:'float', value } },
              function(value) { return { type:'int', value } },
              peg$otherExpectation("string"),
              "'",
              peg$literalExpectation("'", false),
              /^[^']/,
              peg$classExpectation(["'"], true, false),
              function(chars) { return chars.join("") },
              "\"",
              peg$literalExpectation("\"", false),
              /^[^"]/,
              peg$classExpectation(["\""], true, false),
              peg$otherExpectation("number"),
              peg$otherExpectation("real"),
              "-",
              peg$literalExpectation("-", false),
              /^[0-9]/,
              peg$classExpectation([["0", "9"]], false, false),
              ".",
              peg$literalExpectation(".", false),
              function() { return parseFloat(text(), 10); },
              peg$otherExpectation("integer"),
              function() { return parseInt(text(), 10); },
              peg$otherExpectation("optional whitespace"),
              /^[ \t\n\r]/,
              peg$classExpectation([" ", "\t", "\n", "\r"], false, false),
              peg$otherExpectation("inline whitespace"),
              /^[ \t]/,
              peg$classExpectation([" ", "\t"], false, false),
              peg$otherExpectation("whitespace"),
              peg$otherExpectation("line break(s)"),
              /^[\n\r]/,
              peg$classExpectation(["\n", "\r"], false, false)
            ],

            peg$bytecode = [
              peg$decode("%;C/D#;&/;$;F/2$;!/)$8$: $\"\" )($'#(#'#(\"'#&'#"),
              peg$decode("%;$/;#;F/2$;!/)$8#:!#\"\" )(#'#(\"'#&'#.@ &%;$/6#;F.\" &\"/($8\":\"\"!!)(\"'#&'#"),
              peg$decode("%;$/1#;F/($8\":#\"!!)(\"'#&'#"),
              peg$decode("%;$/6#;F.\" &\"/($8\":#\"!!)(\"'#&'#"),
              peg$decode(";(./ &;-.) &;%.# &;'"),
              peg$decode("<%2%\"\"6%7&/D#$4'\"\"5!7(0)*4'\"\"5!7(&/($8\":)\"! )(\"'#&'#=.\" 7$"),
              peg$decode("<%2+\"\"6+7,/\xD9#;D/\xD0$;?/\xC7$;D/\xBE$2-\"\"6-7./\xAF$;D/\xA6$2/\"\"6/70/\x97$;D/\x8E$;?/\x85$;D/|$2-\"\"6-7./m$;D/d$21\"\"6172/U$;D/L$;B/C$23\"\"6374/4$;B/+$81:51$.(\" )(1'#(0'#(/'#(.'#(-'#(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7*"),
              peg$decode("<%27\"\"6778/e#;D/\\$;=/S$;D/J$29\"\"697:/;$;D/2$;>/)$8':;'\"$ )(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 76"),
              peg$decode("<%;)/:#;D/1$;*/($8#:=#! )(#'#(\"'#&'#=.\" 7<"),
              peg$decode("<2?\"\"6?7@.) &2A\"\"6A7B=.\" 7>"),
              peg$decode("%;</\xA9#;D/\xA0$2-\"\"6-7./\x91$;D/\x88$2C\"\"6C7D/y$;D/p$;</g$;D/^$;,/U$;D/L$2E\"\"6E7F/=$;D/4$;+/+$8-:G-$,&$ )(-'#(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\xA0 &%;</\x96#;D/\x8D$2-\"\"6-7./~$;D/u$2C\"\"6C7D/f$;D/]$;</T$;D/K$2E\"\"6E7F/<$;D/3$;+/*$8+:H+#*$ )(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"),
              peg$decode("<%2J\"\"6J7K/}#;C/t$;B/k$;C/b$2L\"\"6L7M/S$;C/J$;B/A$;C/8$2N\"\"6N7O/)$8):P)\"&\")()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7I"),
              peg$decode("<%2R\"\"6R7S/R#;D/I$2T\"\"6T7U/:$;D/1$;@/($8%:V%! )(%'#($'#(#'#(\"'#&'#=.\" 7Q"),
              peg$decode("<%2X\"\"6X7Y/\x95#;D/\x8C$2-\"\"6-7./}$;D/t$;</k$;C/b$2Z\"\"6Z7[/S$;C/J$;./A$;C/8$2\\\"\"6\\7]/)$8+:^+\"&\")(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7W"),
              peg$decode("<;1.) &;0.# &;/=.\" 7_"),
              peg$decode("<;2.# &;9=.\" 7`"),
              peg$decode("<%;//S#;D/J$2b\"\"6b7c/;$;E/2$;./)$8%:d%\"$ )(%'#($'#(#'#(\"'#&'#=.\" 7a"),
              peg$decode("<%;//S#;D/J$2f\"\"6f7g/;$;E/2$;./)$8%:h%\"$ )(%'#($'#(#'#(\"'#&'#=.\" 7e"),
              peg$decode("<%;3/[#;E/R$$;4/&#0#*;4&&&#/<$;E/3$;6/*$8%:j%#$\" )(%'#($'#(#'#(\"'#&'#.\x8C &%;3/H#;E/?$$;4/&#0#*;4&&&#/)$8#:k#\"\" )(#'#(\"'#&'#.W &%;3/;#;E/2$;6/)$8#:l#\"\" )(#'#(\"'#&'#./ &%;3/' 8!:m!! )=.\" 7i"),
              peg$decode("<%2o\"\"6o7p/}#;D/t$;7/k$;C/b$2Z\"\"6Z7[/S$;C/J$;./A$;C/8$2\\\"\"6\\7]/)$8):q)\"&\")()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7n"),
              peg$decode("<%2s\"\"6s7t/\x95#;D/\x8C$2o\"\"6o7p/}$;D/t$;7/k$;C/b$2Z\"\"6Z7[/S$;C/J$;./A$;C/8$2\\\"\"6\\7]/)$8+:q+\"&\")(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7r"),
              peg$decode("<%;4/;#;D/2$;5/)$8#:!#\"\" )(#'#(\"'#&'#./ &%;4/' 8!:\"!! )=.\" 7u"),
              peg$decode("<%2s\"\"6s7t/j#;D/a$2Z\"\"6Z7[/R$;C/I$;./@$;C/7$2\\\"\"6\\7]/($8':w'!\")(''#(&'#(%'#($'#(#'#(\"'#&'#=.\" 7v"),
              peg$decode("<%%2y\"\"6y7z/,#;D/#$+\")(\"'#&'#.\" &\"/]#;8/T$;D/K$2R\"\"6R7S/<$;D/3$;7/*$8&:{&#%$ )(&'#(%'#($'#(#'#(\"'#&'#.Z &%%2y\"\"6y7z/,#;D/#$+\")(\"'#&'#.\" &\"/2#;8/)$8\":|\"\"! )(\"'#&'#=.\" 7x"),
              peg$decode("<%2~\"\"6~7\x7F/R#;D/I$;</@$;D/7$2\x80\"\"6\x807\x81/($8%:\x82%!\")(%'#($'#(#'#(\"'#&'#.\xE2 &%2~\"\"6~7\x7F/R#;D/I$;</@$;D/7$2\x83\"\"6\x837\x84/($8%:\x85%!\")(%'#($'#(#'#(\"'#&'#.\x9D &%;</S#;D/J$2\x86\"\"6\x867\x87/;$;D/2$;</)$8%:\x88%\"$ )(%'#($'#(#'#(\"'#&'#.] &%;</S#;D/J$2\x89\"\"6\x897\x8A/;$;D/2$;</)$8%:\x8B%\"$ )(%'#($'#(#'#(\"'#&'#=.\" 7}"),
              peg$decode("%2\x8C\"\"6\x8C7\x8D/j#;D/a$2\x8E\"\"6\x8E7\x8F/R$;D/I$2\x90\"\"6\x907\x91/:$;D/1$;?/($8':\x92'! )(''#(&'#(%'#($'#(#'#(\"'#&'#.\u038F &%2\x93\"\"6\x937\x94/j#;D/a$2\x95\"\"6\x957\x96/R$;D/I$2~\"\"6~7\x7F/:$;D/1$;</($8':\x97'! )(''#(&'#(%'#($'#(#'#(\"'#&'#.\u0332 &%2\x93\"\"6\x937\x94/\x82#;D/y$2\x86\"\"6\x867\x87/j$;D/a$2\x98\"\"6\x987\x99/R$;D/I$2~\"\"6~7\x7F/:$;D/1$;</($8):\x9A)! )()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u02BD &%2\x9B\"\"6\x9B7\x9C/:#;D/1$;?/($8#:\x9D#! )(#'#(\"'#&'#.\u0290 &%;</S#;D/J$2\x9E\"\"6\x9E7\x9F/;$;D/2$;</)$8%:\xA0%\"$ )(%'#($'#(#'#(\"'#&'#.\u0250 &%;</S#;D/J$2\xA1\"\"6\xA17\xA2/;$;D/2$;</)$8%:\xA3%\"$ )(%'#($'#(#'#(\"'#&'#.\u0210 &%;</~#;D/u$2\xA4\"\"6\xA47\xA5/f$;D/]$;</T$;D/K$2\x8E\"\"6\x8E7\x8F/<$;D/3$;</*$8):\xA6)#($ )()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u01A5 &%;</S#;D/J$2\xA7\"\"6\xA77\xA8/;$;D/2$;?/)$8%:\xA9%\"$ )(%'#($'#(#'#(\"'#&'#.\u0165 &%;</@#;D/7$2\xAA\"\"6\xAA7\xAB/($8#:\xAC#!\")(#'#(\"'#&'#.\u0138 &%;</\x96#;D/\x8D$2\xAD\"\"6\xAD7\xAE/~$;D/u$2\x8E\"\"6\x8E7\x8F/f$;D/]$;+/T$;D/K$2\xAF\"\"6\xAF7\xB0/<$;D/3$;:/*$8+:\xB1+#*$ )(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\xB5 &%;</k#;D/b$2\xAD\"\"6\xAD7\xAE/S$;D/J$2\x8E\"\"6\x8E7\x8F/;$;D/2$;+/)$8':\xB2'\"& )(''#(&'#(%'#($'#(#'#(\"'#&'#.] &%;</S#;D/J$2\xA7\"\"6\xA77\xA8/;$;D/2$;</)$8%:\xA9%\"$ )(%'#($'#(#'#(\"'#&'#"),
              peg$decode("<%;@/@#;D.\" &\"/2$;;/)$8#:\xB4#\"\" )(#'#(\"'#&'#=.\" 7\xB3"),
              peg$decode("<2\xB6\"\"6\xB67\xB7.5 &2\xB8\"\"6\xB87\xB9.) &2\xBA\"\"6\xBA7\xBB=.\" 7\xB5"),
              peg$decode(";?./ &%;=/' 8!:\xBC!! )"),
              peg$decode("<%$4\xBE\"\"5!7\xBF/,#0)*4\xBE\"\"5!7\xBF&&&#/& 8!:\xC0! )=.\" 7\xBD"),
              peg$decode("<%;?/' 8!:\xC2!! ).A &%;A/' 8!:\xC3!! )./ &%;B/' 8!:\xC4!! )=.\" 7\xC1"),
              peg$decode("<%2\xC6\"\"6\xC67\xC7/Y#$4\xC8\"\"5!7\xC9/,#0)*4\xC8\"\"5!7\xC9&&&#/7$2\xC6\"\"6\xC67\xC7/($8#:\xCA#!!)(#'#(\"'#&'#.i &%2\xCB\"\"6\xCB7\xCC/Y#$4\xCD\"\"5!7\xCE/,#0)*4\xCD\"\"5!7\xCE&&&#/7$2\xCB\"\"6\xCB7\xCC/($8#:\xCA#!!)(#'#(\"'#&'#=.\" 7\xC5"),
              peg$decode("<;A.# &;B=.\" 7\xCF"),
              peg$decode("<%2\xD1\"\"6\xD17\xD2.\" &\"/z#$4\xD3\"\"5!7\xD4/,#0)*4\xD3\"\"5!7\xD4&&&#/X$2\xD5\"\"6\xD57\xD6/I$$4\xD3\"\"5!7\xD4/,#0)*4\xD3\"\"5!7\xD4&&&#/'$8$:\xD7$ )($'#(#'#(\"'#&'#=.\" 7\xD0"),
              peg$decode("<%2\xD1\"\"6\xD17\xD2.\" &\"/I#$4\xD3\"\"5!7\xD4/,#0)*4\xD3\"\"5!7\xD4&&&#/'$8\":\xD9\" )(\"'#&'#=.\" 7\xD8"),
              peg$decode("<$4\xDB\"\"5!7\xDC0)*4\xDB\"\"5!7\xDC&=.\" 7\xDA"),
              peg$decode("<$4\xDE\"\"5!7\xDF/,#0)*4\xDE\"\"5!7\xDF&&&#=.\" 7\xDD"),
              peg$decode("<$4\xDB\"\"5!7\xDC/,#0)*4\xDB\"\"5!7\xDC&&&#=.\" 7\xE0"),
              peg$decode("<%$4\xE2\"\"5!7\xE3/,#0)*4\xE2\"\"5!7\xE3&&&#/?#$4\xDB\"\"5!7\xDC0)*4\xDB\"\"5!7\xDC&/#$+\")(\"'#&'#=.\" 7\xE1")
            ],

            peg$currPos          = 0,
            peg$savedPos         = 0,
            peg$posDetailsCache  = [{ line: 1, column: 1 }],
            peg$maxFailPos       = 0,
            peg$maxFailExpected  = [],
            peg$silentFails      = 0,

            peg$result;

        if ("startRule" in options) {
          if (!(options.startRule in peg$startRuleIndices)) {
            throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
          }

          peg$startRuleIndex = peg$startRuleIndices[options.startRule];
        }

        function text() {
          return input.substring(peg$savedPos, peg$currPos);
        }

        function error(message, location) {
          location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);

          throw peg$buildSimpleError(message, location);
        }

        function peg$literalExpectation(text, ignoreCase) {
          return { type: "literal", text: text, ignoreCase: ignoreCase };
        }

        function peg$classExpectation(parts, inverted, ignoreCase) {
          return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
        }

        function peg$endExpectation() {
          return { type: "end" };
        }

        function peg$otherExpectation(description) {
          return { type: "other", description: description };
        }

        function peg$computePosDetails(pos) {
          var details = peg$posDetailsCache[pos], p;

          if (details) {
            return details;
          } else {
            p = pos - 1;
            while (!peg$posDetailsCache[p]) {
              p--;
            }

            details = peg$posDetailsCache[p];
            details = {
              line:   details.line,
              column: details.column
            };

            while (p < pos) {
              if (input.charCodeAt(p) === 10) {
                details.line++;
                details.column = 1;
              } else {
                details.column++;
              }

              p++;
            }

            peg$posDetailsCache[pos] = details;
            return details;
          }
        }

        function peg$computeLocation(startPos, endPos) {
          var startPosDetails = peg$computePosDetails(startPos),
              endPosDetails   = peg$computePosDetails(endPos);

          return {
            start: {
              offset: startPos,
              line:   startPosDetails.line,
              column: startPosDetails.column
            },
            end: {
              offset: endPos,
              line:   endPosDetails.line,
              column: endPosDetails.column
            }
          };
        }

        function peg$fail(expected) {
          if (peg$currPos < peg$maxFailPos) { return; }

          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }

          peg$maxFailExpected.push(expected);
        }

        function peg$buildSimpleError(message, location) {
          return new peg$SyntaxError(message, null, null, location);
        }

        function peg$buildStructuredError(expected, found, location) {
          return new peg$SyntaxError(
            peg$SyntaxError.buildMessage(expected, found),
            expected,
            found,
            location
          );
        }

        function peg$decode(s) {
          var bc = new Array(s.length), i;

          for (i = 0; i < s.length; i++) {
            bc[i] = s.charCodeAt(i) - 32;
          }

          return bc;
        }

        function peg$parseRule(index) {
          var bc    = peg$bytecode[index],
              ip    = 0,
              ips   = [],
              end   = bc.length,
              ends  = [],
              stack = [],
              params, i;

          while (true) {
            while (ip < end) {
              switch (bc[ip]) {
                case 0:
                  stack.push(peg$consts[bc[ip + 1]]);
                  ip += 2;
                  break;

                case 1:
                  stack.push(void 0);
                  ip++;
                  break;

                case 2:
                  stack.push(null);
                  ip++;
                  break;

                case 3:
                  stack.push(peg$FAILED);
                  ip++;
                  break;

                case 4:
                  stack.push([]);
                  ip++;
                  break;

                case 5:
                  stack.push(peg$currPos);
                  ip++;
                  break;

                case 6:
                  stack.pop();
                  ip++;
                  break;

                case 7:
                  peg$currPos = stack.pop();
                  ip++;
                  break;

                case 8:
                  stack.length -= bc[ip + 1];
                  ip += 2;
                  break;

                case 9:
                  stack.splice(-2, 1);
                  ip++;
                  break;

                case 10:
                  stack[stack.length - 2].push(stack.pop());
                  ip++;
                  break;

                case 11:
                  stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
                  ip += 2;
                  break;

                case 12:
                  stack.push(input.substring(stack.pop(), peg$currPos));
                  ip++;
                  break;

                case 13:
                  ends.push(end);
                  ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

                  if (stack[stack.length - 1]) {
                    end = ip + 3 + bc[ip + 1];
                    ip += 3;
                  } else {
                    end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                    ip += 3 + bc[ip + 1];
                  }

                  break;

                case 14:
                  ends.push(end);
                  ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

                  if (stack[stack.length - 1] === peg$FAILED) {
                    end = ip + 3 + bc[ip + 1];
                    ip += 3;
                  } else {
                    end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                    ip += 3 + bc[ip + 1];
                  }

                  break;

                case 15:
                  ends.push(end);
                  ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

                  if (stack[stack.length - 1] !== peg$FAILED) {
                    end = ip + 3 + bc[ip + 1];
                    ip += 3;
                  } else {
                    end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                    ip += 3 + bc[ip + 1];
                  }

                  break;

                case 16:
                  if (stack[stack.length - 1] !== peg$FAILED) {
                    ends.push(end);
                    ips.push(ip);

                    end = ip + 2 + bc[ip + 1];
                    ip += 2;
                  } else {
                    ip += 2 + bc[ip + 1];
                  }

                  break;

                case 17:
                  ends.push(end);
                  ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

                  if (input.length > peg$currPos) {
                    end = ip + 3 + bc[ip + 1];
                    ip += 3;
                  } else {
                    end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                    ip += 3 + bc[ip + 1];
                  }

                  break;

                case 18:
                  ends.push(end);
                  ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

                  if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
                    end = ip + 4 + bc[ip + 2];
                    ip += 4;
                  } else {
                    end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                    ip += 4 + bc[ip + 2];
                  }

                  break;

                case 19:
                  ends.push(end);
                  ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

                  if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
                    end = ip + 4 + bc[ip + 2];
                    ip += 4;
                  } else {
                    end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                    ip += 4 + bc[ip + 2];
                  }

                  break;

                case 20:
                  ends.push(end);
                  ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

                  if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
                    end = ip + 4 + bc[ip + 2];
                    ip += 4;
                  } else {
                    end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                    ip += 4 + bc[ip + 2];
                  }

                  break;

                case 21:
                  stack.push(input.substr(peg$currPos, bc[ip + 1]));
                  peg$currPos += bc[ip + 1];
                  ip += 2;
                  break;

                case 22:
                  stack.push(peg$consts[bc[ip + 1]]);
                  peg$currPos += peg$consts[bc[ip + 1]].length;
                  ip += 2;
                  break;

                case 23:
                  stack.push(peg$FAILED);
                  if (peg$silentFails === 0) {
                    peg$fail(peg$consts[bc[ip + 1]]);
                  }
                  ip += 2;
                  break;

                case 24:
                  peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];
                  ip += 2;
                  break;

                case 25:
                  peg$savedPos = peg$currPos;
                  ip++;
                  break;

                case 26:
                  params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);
                  for (i = 0; i < bc[ip + 3]; i++) {
                    params[i] = stack[stack.length - 1 - params[i]];
                  }

                  stack.splice(
                    stack.length - bc[ip + 2],
                    bc[ip + 2],
                    peg$consts[bc[ip + 1]].apply(null, params)
                  );

                  ip += 4 + bc[ip + 3];
                  break;

                case 27:
                  stack.push(peg$parseRule(bc[ip + 1]));
                  ip += 2;
                  break;

                case 28:
                  peg$silentFails++;
                  ip++;
                  break;

                case 29:
                  peg$silentFails--;
                  ip++;
                  break;

                default:
                  throw new Error("Invalid opcode: " + bc[ip] + ".");
              }
            }

            if (ends.length > 0) {
              end = ends.pop();
              ip = ips.pop();
            } else {
              break;
            }
          }

          return stack[0];
        }


        	const spriteSize = 80;
            const placeholders = { player: { type:'string', value:'player' } };

        	function resolveTime(amount, unit) {
            	switch (unit) {
                	case 'ms':
                    	return amount;
                        break;
                	case 's':
                    	return amount * 1000;
                        break;
                	case 'm':
                    	return amount * 1000 * 60;
                        break;
                }
            }
            function indexPlaceholder(name, value) {
            	placeholders[name] = { ...value };
                return {type: "comment", content: "# placeholder indexed"};
            }
            function lookupPlaceholder(name, allowedTypes) {
            	const node = placeholders[name];
                if (node === undefined) {
                	return error("Placeholder lookup for '"+name+"' failed");
                }
                if (allowedTypes !== undefined && !allowedTypes.includes(node.type)) {
                	return error("Invalid type used: '" + node.type + "' but requires: " + allowedTypes.join(", "))
                }
                return node.value;
            }
            function relativeToAbsoluteSize(size) {
            	return spriteSize * size;
            }


        peg$result = peg$parseRule(peg$startRuleIndex);

        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail(peg$endExpectation());
          }

          throw peg$buildStructuredError(
            peg$maxFailExpected,
            peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
            peg$maxFailPos < input.length
              ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
              : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
          );
        }
      }

      return {
        SyntaxError: peg$SyntaxError,
        parse:       peg$parse
      };
    })();

    function dragElement(elmnt) {
        let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

        elmnt.onmousedown = dragMouseDown;

        function dragMouseDown(e) {
            e = e || window.event;
            e.cancelBubble = true;
            e.preventDefault();
            // get the mouse cursor position at startup:
            pos3 = e.clientX;
            pos4 = e.clientY;
            document.onmouseup = closeDragElement;
            // call a function whenever the cursor moves:
            document.onmousemove = elementDrag;
        }

        function elementDrag(e) {
            e = e || window.event;
            e.preventDefault();
            // calculate the new cursor position:
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;
            // set the element's new position:
            elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
            elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
        }

        function closeDragElement() {
            // stop moving when mouse button is released:
            document.onmouseup = null;
            document.onmousemove = null;
            const y = parseInt(elmnt.style.top.replace("px"), 10);
            const x = parseInt(elmnt.style.left.replace("px"), 10);
            console.log("new position", `(${x}, ${y})`);
        }
    }

    const _dialogContainer = document.createElement("div");
    _dialogContainer.className = "dialog-container";

    const _loadedScenes = { };
    let _currentScene, _container, _player;

    // interaction implementations
    const functions = {

        // 2nd arg: { entity, action:"says", message }
        says: (scene, actedOnEntity, { message }) => new Promise(acc => {
            const dialog = document.createElement('span');
            dialog.className = 'dialog';
            dialog.style.top = (actedOnEntity.__domElement.style.top.replace('px', '') - 40) + 'px';
            dialog.style.left = actedOnEntity.__domElement.style.left;
            dialog.innerText = message;

            document.body.appendChild(dialog);

            const delay = 500 + (message.length * 45);
            setTimeout(() => {
                dialog.remove();
                acc();
            }, delay);
        }),

        // 2nd arg: { entity, action:"gets", status }
        gets: (scene, actedOnEntity, { entity, status }) => {
            actedOnEntity.statusses.push(status);
            if (entity === 'player') {
                displayMsg(`you are ${status}`);
            }
            else {
                displayMsg(`${entity} is ${status}`);
            }
        },

        // 2nd arg: { entity, action:"give", item, toEntity }
        give: (scene, actedOnEntity, {entity, item, toEntity}) => {
            const entityObj = scene.entities[entity];
            if (removeFromArray(entityObj.items, item)) {
                const toEntityObj = scene.entities[toEntity];
                toEntityObj.items.push(item);
                toEntity = toEntity === 'player' ? 'you' : toEntity;
                if (entity === 'player') {
                    displayMsg(`you give ${item} to ${toEntity}`);
                }
                else {
                    displayMsg(`${entity} gives ${item} to ${toEntity}`);
                }
            }
            else {
                console.warn(`${entity} does not have the item ${item}`);
            }
        },

        // 2nd arg: { entity, action:"move_to", position, time }
        move_to: async (scene, actedOnEntity, { position, time}) => {
            const movingRight = actedOnEntity.position.x < position.x;
            flip(actedOnEntity.__domElement, movingRight);
            actedOnEntity.__domElement.style.transition = `top ${time}ms ease 0s, left ${time}ms ease 0s`;
            actedOnEntity.__domElement.style.top = scene.transform(position.y) + 'px';
            actedOnEntity.__domElement.style.left = scene.transform(position.x) + 'px';
            actedOnEntity.position = position;
            await delayAsync(time);
        },

        // 2nd arg: { action: "goto_scene", scene }
        goto_scene: (_, actedOnEntity, {scene}) => runScene(scene),

        // 2nd arg: { action: "new_objective",  objective }
        new_objective: (scene, actedOnEntity, { objective }) => {
            _player.objectives.push(objective);
            displayMsg(`objective started: ` + objective);
        },

        // 2nd arg: { action: "completed_objective",  objective }
        completed_objective: (scene, actedOnEntity, { objective }) => {
            removeFromArray(_player.objectives, objective);
            _player.completedObjectives.push(objective);
            displayMsg(`objective completed: ${objective}`);
        },

        // 2nd arg: { action: "display", text }
        display: (scene, actedOnEntity, { text }) => {
            displayMsg(text);
        },

        // 2nd arg: { entity, action:"receives", item }
        receives: (scene, actedOnEntity, { entity, item }) => {
            actedOnEntity.items.push(item);
            if (entity === 'player') {
                displayMsg(`you receive ${item}`);
            }
            else {
                displayMsg(`${entity} receives ${item}`);
            }
        },

        // 2nd arg: { entity, action:"disappear" }
        disappear: (scene, actedOnEntity) => {
            delete scene.entities[actedOnEntity.id];
            actedOnEntity.__domElement.remove();
        },

        // 2nd arg: { entity, action:"move_to", position, time }
        conditional: async (scene, actedOnEntity, interaction) => {
            if (checkConditions(interaction.ifBranch.conditions, scene)) {
                await executeInteractions(interaction.ifBranch.interactions, scene);
            }
            else {
                if (interaction.elseIfBranches) {
                    for (let i = 0; i < interaction.elseIfBranches.length; i++) {
                        const elseIf = interaction.elseIfBranches[i];
                        if (checkConditions(elseIf.conditions, scene)) {
                            await executeInteractions(elseIf.interactions, scene);
                            return;
                        }
                    }
                }
                if (interaction.elseBranch) {
                    await executeInteractions(interaction.elseBranch.interactions, scene);
                }
            }
        }
    };

    const conditionFunctions = {
        has: (scene, {entity, item}) => {
            const entityObj = scene.entities[entity];
            return entityObj.items.includes(item);
        },

        is: (scene, {entity, status}) => {
            const entityObj = scene.entities[entity];
            return entityObj.statusses.includes(status);
        },

        objective_started: (scene, {objective}) => {
            return _player.objectives.includes(objective);
        },

        objective_completed: (scene, {objective}) => {
            return _player.completedObjectives.includes(objective);
        },
    };

    // execute interactions
    async function executeInteractions(interactionNode, scene) {
        if (interactionNode.type === 'par_interaction') {
            await Promise.all(interactionNode.interactions.map(interaction => executeInteractions(interaction, scene)));
        }
        else if (interactionNode.type === 'seq_interaction') {
            await executeInteractions(interactionNode.interaction, scene);
            if (interactionNode.next) {
                await executeInteractions(interactionNode.next, scene);
            }
        }
        else {
            await executeInteraction(interactionNode, scene);
        }
    }

    async function executeInteraction(interaction, scene) {
        const actedOnEntity = interaction.entity && scene.entities[interaction.entity];

        if (functions[interaction.action] !== undefined) {
            await functions[interaction.action](scene, actedOnEntity, interaction);
        }
        else {
            console.warn('interaction function not found', interaction.action);
        }
    }

    function checkConditions(conditions, scene) {
        for (let i = 0; i < conditions.length; i++) {
            const condition = conditions[i];

            if (conditionFunctions[condition.type] !== undefined) {
                const val = conditionFunctions[condition.type](scene, condition);
                if (val === condition.negate) // instead of checking the two possible combinations
                    return false;
            }
            else {
                console.warn('condition evaluator not found', condition.type);
                return false;
            }
        }
        return true;
    }

    function displayMsg(msg) {
        const message = document.createElement('div');
        message.innerText = msg;
        _dialogContainer.insertBefore(message, _dialogContainer.firstChild);
    }

    function ensureProps(entity){
        if (entity.statusses === undefined) {
            entity.statusses = [];
            entity.items = [];
        }
    }

    function drawScene(scene) {
        const drawStart = Date.now();
        Object.values(scene.entities).forEach(entity => drawEntity(entity, scene));
        scene.interactions.forEach(interaction => bindInteraction(interaction, scene));
        scene.entities['player'] = _player;
        console.log(`drawing took ${Date.now() - drawStart}ms`);
    }

    function drawEntity(entity, scene) {
        entity.__domElement = document.createElement('img');
        entity.__domElement.title = entity.id;
        entity.__domElement.src = `${entity.sprite}`;
        entity.__domElement.style.position = 'absolute';
        entity.__domElement.style.top = `${scene.transform(entity.position.y)}px`;
        entity.__domElement.style.left = `${scene.transform(entity.position.x)}px`;
        const size = `${scene.transform(entity.size)}px`;
        entity.__domElement.style.height = size;
        entity.__domElement.style.width = size;
        _container.appendChild(entity.__domElement);
        dragElement(entity.__domElement);
    }

    function bindInteraction(interaction, scene) {
        const entity = scene.entities[interaction.entity];
        try {
            entity.__domElement.onclick = async () => {
                if (entity.__interacting) return;
                entity.__interacting = true;
                await executeInteractions(interaction.interactions, scene);
                entity.__interacting = false;
            };
        }
        catch (e) {
            console.log('binding interaction to entity failed', interaction, entity, e);
        }
    }

    function removeFromArray (array, item) {
        const index = array.indexOf(item);
        if (index !== -1) {
            array.splice(index, 1);
            return true;
        }
        return false;
    }

    function flip(element, right) {
        element.className = right ? 'flipped' : '';
    }

    function delayAsync(ms) {
        return new Promise(acc => {
            setTimeout(acc, ms);
        });
    }

    // parsing and running scenes
    async function interpret(code) {
        let ast;
        try {
            const parseStart = Date.now();
            ast = await parser.parse(code);
            console.log(`parsing took ${Date.now() - parseStart}ms`);
        }
        catch (e) {
            throw new Error(`Syntax error at ${e.location.start.line}:${e.location.start.offset}: ${e.message}`);
        }

        const scene = {
            entities: Object.create(null),
            interactions: [],
            ...ast.scene
        };
        ast.lines.forEach(node => {
            switch (node.type) {
                case 'entity':
                    ensureProps(node);
                    scene.entities[node.id] = node;
                    break;
                case 'interaction':
                    scene.interactions.push(node);
                    break;
                case 'comment':
                    break;
                default:
                    console.log('unknown node', node.type);
                    break;
            }
        });

        return scene;
    }

    async function getFileContent(url) {
        const loadStart = Date.now();
        const response = await fetch(url);
        const content = await response.text();
        console.log(`downloading took ${Date.now() - loadStart}ms`);
        return content;
    }

    async function runScene(scenePath) {

        if (!scenePath.toLowerCase().endsWith(".pcas"))
            scenePath += ".pcas";

        let scene;

        if (_loadedScenes[scenePath] !== undefined) {
            scene = _loadedScenes[scenePath];
        }
        else {
            const code = await getFileContent(scenePath);
            try {
                scene = await interpret(code);
            }
            catch (e) {
                return console.error(`could not parse the pca code at '${scenePath}'`, e);
            }

            _loadedScenes[scenePath] = scene;
            console.log(`loaded scene: ${scenePath}`);
        }


        console.log("scene resolution", scene.w, scene.h);
        scene.scale = _container.__width / scene.w;
        console.log("scene scaling", scene.scale);
        scene.transform = originalSize => scene.scale * originalSize;
        _container.style.height = scene.transform(scene.h) + 'px';
        _container.style['background-image'] = `url(${scene.background})`;

        // remove current scene if any
        if (_currentScene !== undefined) {
            delete _currentScene.entities.player;
            Object.values(_currentScene.entities).forEach(entity => entity.__domElement.remove());
        }
        _currentScene = scene;

        drawScene(scene);
        displayMsg(`you are ${scene.id}`);
    }

    async function start(firstScenePath, container) {
        _player = {
            objectives: [],
            completedObjectives: [],
            statusses: [],
            items: []
        };

        _container = container;
        const actualWidth = container.offsetWidth;
        const actualHeigth = container.offsetHeight;
        console.log("actual resolution", actualWidth, actualHeigth);

        _container.__height = actualHeigth;
        _container.__width = actualWidth;

        container.onclick = ev => {
            ev.cancelBubble = true;
            console.log("clicked at", '(' + parseInt(ev.clientX / _currentScene.scale) + ', ' + parseInt(ev.clientY / _currentScene.scale) + ')');
        };

        document.body.appendChild(_dialogContainer);
        await runScene(firstScenePath, {w: actualWidth, h: actualHeigth});
    }

    exports.interpret = interpret;
    exports.start = start;

    return exports;

}({}));
//# sourceMappingURL=built-engine.js.map
